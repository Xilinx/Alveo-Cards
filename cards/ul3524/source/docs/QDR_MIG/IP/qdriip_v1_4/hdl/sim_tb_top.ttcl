<: setOutputDirectory "tb" :>
<: setFileName sim_tb_top :>
<: setFileExtension ".sv" :>
<: setFileType "verilogSource" :>
<: variable tcl_scope :>
<: variable tcl_ipinst :>
<: set tcl_scope xit :>
<: set tcl_ipinst [current_inst] :>
<: source_subcore_ipfile xilinx.com:ip:mem:1.4 utility/db.tcl :>

<: set memName [ getmodelparam C0.ControllerType ] :>

/*
Copyright (c) 2023, Advanced Micro Devices, Inc. All rights reserved.
SPDX-License-Identifier: MIT
*/

//******************************************************************************
//   ____  ____
//  /   /\/   /
// /___/  \  /    Vendor             : Xilinx
// \   \   \/     Version            : 1.1
//  \   \         Application        : QDRIIP
//  /   /         Filename           : sim_tb_top.sv
// /___/   /\     Date Last Modified : $Date: 2014/09/03 $
// \   \  /  \    Date Created       : Thu Apr 18 2013
//  \___\/\___\
//
// Device           : UltraScale
// Design Name      : <: print ${memName} :>
// Purpose          :
//                   Top-level testbench for testing Memory interface.
//                   Instantiates:
//                     1. IP_TOP (top-level representing FPGA, contains core,
//                        clocking, built-in testbench/memory checker and other
//                        support structures)
//                     2. Memory Model
//                     3. Miscellaneous clock generation and reset logic
// Reference        :
// Revision History :
//*****************************************************************************

`timescale 1ps/1ps

`ifdef XILINX_SIMULATOR
module short(in1, in1);
inout in1;
endmodule
`endif

module sim_tb_top;

// Input clock period
  <: foreach c { 0 } { :>
     <: set memTypes [ list qdriip ] :>
     <: foreach memType $memTypes { :>
  localparam NUM_DEVICES      = <: print [ getmodelparam C${c}.${memType}_NUM_DEVICES ] :>;
  localparam MEM_DEVICE_WIDTH = <: print [ getmodelparam C${c}.${memType}_MEM_DEVICE_WIDTH ] :>;
  localparam BURST_LEN        = <: print [ getmodelparam C${c}.${memType}_BURST_LEN ] :>;
  localparam DATA_WIDTH       = <: print [ getmodelparam C${c}.${memType}_DATA_WIDTH ] :>;
  localparam MEM_LATENCY      = "<: print [ getmodelparam C${c}.${memType}_MEM_READ_LATENCY ] :>";

    <:}:>
    <:}:>

reg                       sys_rst;
reg                       sys_clk_i;

      <: foreach c { 0 } { :>
       <: set memTypes [ list qdriip ] :>
       <: foreach memType $memTypes { :>

wire          c<=:c:>_sys_clk_p;
wire          c<=:c:>_sys_clk_n;
wire          c<=:c:>_init_calib_complete;
wire          c<=:c:>_data_compare_error;
wire [<: print [expr {[getmodelparam C${c}.[string toupper ${memType}]_DATA_WIDTH] - 1}] :>:0]   c<=:c:>_<: print [string tolower ${memType}]:>_d;
wire [<: print [expr {[getmodelparam C${c}.[string toupper ${memType}]_NUM_DEVICES] - 1}] :>:0]    c<=:c:>_<: print [string tolower ${memType}]:>_k_p;
wire [<: print [expr {[getmodelparam C${c}.[string toupper ${memType}]_NUM_DEVICES] - 1}] :>:0]    c<=:c:>_<: print [string tolower ${memType}]:>_k_n;
wire [<: print [expr {([getmodelparam C${c}.[string toupper ${memType}]_DATA_WIDTH]/9) - 1}] :>:0]    c<=:c:>_<: print [string tolower ${memType}]:>_bw_n;
wire          c<=:c:>_<: print [string tolower ${memType}]:>_r_n;
wire          c<=:c:>_<: print [string tolower ${memType}]:>_w_n;
wire          c<=:c:>_<: print [string tolower ${memType}]:>_doff_n;
wire [<: print [expr {[getmodelparam C${c}.[string toupper ${memType}]_ADDR_WIDTH] - 1}] :>:0]   c<=:c:>_<: print [string tolower ${memType}]:>_sa;
wire [<: print [expr {[getmodelparam C${c}.[string toupper ${memType}]_DATA_WIDTH] - 1}] :>:0]   c<=:c:>_<: print [string tolower ${memType}]:>_q;
wire [<: print [expr {[getmodelparam C${c}.[string toupper ${memType}]_NUM_DEVICES] - 1}] :>:0]    c<=:c:>_<: print [string tolower ${memType}]:>_qvld;
wire [<: print [expr {[getmodelparam C${c}.[string toupper ${memType}]_NUM_DEVICES] - 1}] :>:0]    c<=:c:>_<: print [string tolower ${memType}]:>_cq_p;
wire [<: print [expr {[getmodelparam C${c}.[string toupper ${memType}]_NUM_DEVICES] - 1}] :>:0]    c<=:c:>_<: print [string tolower ${memType}]:>_cq_n;

<:}:>
<:}:>


  //**************************************************************************//
  // Reset Generation
  //**************************************************************************//
  initial begin
     sys_rst = 1'b0;
     #200
     sys_rst = 1'b1;
     #200;
     sys_rst = 1'b0;
     #100;
  end

  //**************************************************************************//
  // Clock Generation
  //**************************************************************************//

  initial
    sys_clk_i = 1'b0;
  always
    sys_clk_i = #(<: print [ getmodelparam  CAL_INPUT_CLK_PERIOD ] :>/2.0) ~sys_clk_i;

<: foreach c { 0 } { :>
  assign c<=:c:>_sys_clk_p = sys_clk_i;
  assign c<=:c:>_sys_clk_n = ~sys_clk_i;
<: } :>
  //===========================================================================
  //                         FPGA Memory Controller instantiation
  //===========================================================================

  example_top 
  u_example_top
    (
    .sys_rst           (sys_rst),
    <: foreach c { 0 } { :>
       <: set memTypes [ list qdriip ] :>
       <: foreach memType $memTypes { :>
    .c<=:c:>_sys_clk_p                  (c<=:c:>_sys_clk_p),
    .c<=:c:>_sys_clk_n                  (c<=:c:>_sys_clk_n),
    .c<=:c:>_init_calib_complete        (c<=:c:>_init_calib_complete),
    .c<=:c:>_<: print [string tolower ${memType}]:>_d                   (c<=:c:>_<: print [string tolower ${memType}]:>_d),
    .c<=:c:>_<: print [string tolower ${memType}]:>_k_p                 (c<=:c:>_<: print [string tolower ${memType}]:>_k_p),
    .c<=:c:>_<: print [string tolower ${memType}]:>_k_n                 (c<=:c:>_<: print [string tolower ${memType}]:>_k_n),
    .c<=:c:>_<: print [string tolower ${memType}]:>_bw_n                (c<=:c:>_<: print [string tolower ${memType}]:>_bw_n),
    .c<=:c:>_<: print [string tolower ${memType}]:>_r_n                 (c<=:c:>_<: print [string tolower ${memType}]:>_r_n),
    .c<=:c:>_<: print [string tolower ${memType}]:>_w_n                 (c<=:c:>_<: print [string tolower ${memType}]:>_w_n),
    .c<=:c:>_<: print [string tolower ${memType}]:>_doff_n              (c<=:c:>_<: print [string tolower ${memType}]:>_doff_n),
    .c<=:c:>_<: print [string tolower ${memType}]:>_sa                  (c<=:c:>_<: print [string tolower ${memType}]:>_sa),
    .c<=:c:>_<: print [string tolower ${memType}]:>_q                   (c<=:c:>_<: print [string tolower ${memType}]:>_q),
    .c<=:c:>_<: print [string tolower ${memType}]:>_cq_p                (c<=:c:>_<: print [string tolower ${memType}]:>_cq_p),
    .c<=:c:>_<: print [string tolower ${memType}]:>_cq_n                (c<=:c:>_<: print [string tolower ${memType}]:>_cq_n),
    .c<=:c:>_data_compare_error    (c<=:c:>_data_compare_error)
    );

  //===========================================================================
  //                         Memory Model instantiation
  //===========================================================================

  genvar i;
  generate
    for(i=0; i<NUM_DEVICES; i=i+1)begin : COMP_INST
      if(BURST_LEN == 4) begin : BL4_INST
        if (MEM_LATENCY == "2") begin : RL2_INST
          if(MEM_DEVICE_WIDTH == 36) begin: X36_INST
            cyqdr2_b4 QDR2PLUS_MEM (
              .TCK   ( 1'b0 ),
              .TMS   ( 1'b1 ),
              .TDI   ( 1'b1 ),
              .TDO   (),
              .D     ( c<=:c:>_<: print [string tolower ${memType}]:>_d[(DATA_WIDTH/NUM_DEVICES*i)+:(DATA_WIDTH/NUM_DEVICES)] ),
              .Q     ( c<=:c:>_<: print [string tolower ${memType}]:>_q[(DATA_WIDTH/NUM_DEVICES*i)+:(DATA_WIDTH/NUM_DEVICES)] ),
              .A     ( c<=:c:>_<: print [string tolower ${memType}]:>_sa),
              .K     ( c<=:c:>_<: print [string tolower ${memType}]:>_k_p[i] ),
              .Kb    ( c<=:c:>_<: print [string tolower ${memType}]:>_k_n[i] ),
              .RPSb  ( c<=:c:>_<: print [string tolower ${memType}]:>_r_n ),
              .WPSb  ( c<=:c:>_<: print [string tolower ${memType}]:>_w_n ),
              .BWS0b ( c<=:c:>_<: print [string tolower ${memType}]:>_bw_n[(4*i)+0] ),
              .BWS1b ( c<=:c:>_<: print [string tolower ${memType}]:>_bw_n[(4*i)+1] ),
              .BWS2b ( c<=:c:>_<: print [string tolower ${memType}]:>_bw_n[(4*i)+2] ),
              .BWS3b ( c<=:c:>_<: print [string tolower ${memType}]:>_bw_n[(4*i)+3] ),
              .CQ    ( c<=:c:>_<: print [string tolower ${memType}]:>_cq_p[i] ),
              .CQb   ( c<=:c:>_<: print [string tolower ${memType}]:>_cq_n[i] ),
              .ZQ    ( 1'b1 ),
              .DOFF  ( 1'b1 ),
              .QVLD  ( )
              );
          end
          if(MEM_DEVICE_WIDTH == 18) begin: X18_INST
            cyqdr2_b4 QDR2PLUS_MEM (
              .TCK   ( 1'b0 ),
              .TMS   ( 1'b1 ),
              .TDI   ( 1'b1 ),
              .TDO   (),
              .D     ( c<=:c:>_<: print [string tolower ${memType}]:>_d[(DATA_WIDTH/NUM_DEVICES*i)+:(DATA_WIDTH/NUM_DEVICES)] ),
              .Q     ( c<=:c:>_<: print [string tolower ${memType}]:>_q[(DATA_WIDTH/NUM_DEVICES*i)+:(DATA_WIDTH/NUM_DEVICES)] ),
              .A     ( c<=:c:>_<: print [string tolower ${memType}]:>_sa),
              .K     ( c<=:c:>_<: print [string tolower ${memType}]:>_k_p[i] ),
              .Kb    ( c<=:c:>_<: print [string tolower ${memType}]:>_k_n[i] ),
              .RPSb  ( c<=:c:>_<: print [string tolower ${memType}]:>_r_n ),
              .WPSb  ( c<=:c:>_<: print [string tolower ${memType}]:>_w_n ),
              .BWS0b ( c<=:c:>_<: print [string tolower ${memType}]:>_bw_n[(2*i)+0] ),
              .BWS1b ( c<=:c:>_<: print [string tolower ${memType}]:>_bw_n[(2*i)+1] ),
              .CQ    ( c<=:c:>_<: print [string tolower ${memType}]:>_cq_p[i] ),
              .CQb   ( c<=:c:>_<: print [string tolower ${memType}]:>_cq_n[i] ),
              .ZQ    ( 1'b1 ),
              .DOFF  ( 1'b1 ),
              .QVLD  ( )
              );
          end
        end else begin : RL_25_INST
          if(MEM_DEVICE_WIDTH == 36) begin: X36_INST
            cyqdr2_b4 QDR2PLUS_MEM (
              .TCK   ( 1'b0 ),
              .TMS   ( 1'b1 ),
              .TDI   ( 1'b1 ),
              .TDO   (),
              .D     ( c<=:c:>_<: print [string tolower ${memType}]:>_d[(DATA_WIDTH/NUM_DEVICES*i)+:(DATA_WIDTH/NUM_DEVICES)] ),
              .Q     ( c<=:c:>_<: print [string tolower ${memType}]:>_q[(DATA_WIDTH/NUM_DEVICES*i)+:(DATA_WIDTH/NUM_DEVICES)] ),
              .A     ( c<=:c:>_<: print [string tolower ${memType}]:>_sa),
              .K     ( c<=:c:>_<: print [string tolower ${memType}]:>_k_p[i] ),
              .Kb    ( c<=:c:>_<: print [string tolower ${memType}]:>_k_n[i] ),
              .RPSb  ( c<=:c:>_<: print [string tolower ${memType}]:>_r_n ),
              .WPSb  ( c<=:c:>_<: print [string tolower ${memType}]:>_w_n ),
              .BWS0b ( c<=:c:>_<: print [string tolower ${memType}]:>_bw_n[(4*i)+0] ),
              .BWS1b ( c<=:c:>_<: print [string tolower ${memType}]:>_bw_n[(4*i)+1] ),
              .BWS2b ( c<=:c:>_<: print [string tolower ${memType}]:>_bw_n[(4*i)+2] ),
              .BWS3b ( c<=:c:>_<: print [string tolower ${memType}]:>_bw_n[(4*i)+3] ),
              .CQ    ( c<=:c:>_<: print [string tolower ${memType}]:>_cq_p[i] ),
              .CQb   ( c<=:c:>_<: print [string tolower ${memType}]:>_cq_n[i] ),
              .ZQ    ( 1'b1 ),
              .DOFF  ( 1'b1 ),
              .QVLD  ( ),
              .ODT   (1'b1)
              );
          end
          if(MEM_DEVICE_WIDTH == 18) begin: X18_INST
            cyqdr2_b4 QDR2PLUS_MEM (
              .TCK   ( 1'b0 ),
              .TMS   ( 1'b1 ),
              .TDI   ( 1'b1 ),
              .TDO   (),
              .D     ( c<=:c:>_<: print [string tolower ${memType}]:>_d[(DATA_WIDTH/NUM_DEVICES*i)+:(DATA_WIDTH/NUM_DEVICES)] ),
              .Q     ( c<=:c:>_<: print [string tolower ${memType}]:>_q[(DATA_WIDTH/NUM_DEVICES*i)+:(DATA_WIDTH/NUM_DEVICES)] ),
              .A     ( c<=:c:>_<: print [string tolower ${memType}]:>_sa),
              .K     ( c<=:c:>_<: print [string tolower ${memType}]:>_k_p[i] ),
              .Kb    ( c<=:c:>_<: print [string tolower ${memType}]:>_k_n[i] ),
              .RPSb  ( c<=:c:>_<: print [string tolower ${memType}]:>_r_n ),
              .WPSb  ( c<=:c:>_<: print [string tolower ${memType}]:>_w_n ),
              .BWS0b ( c<=:c:>_<: print [string tolower ${memType}]:>_bw_n[(2*i)+0] ),
              .BWS1b ( c<=:c:>_<: print [string tolower ${memType}]:>_bw_n[(2*i)+1] ),
              .CQ    ( c<=:c:>_<: print [string tolower ${memType}]:>_cq_p[i] ),
              .CQb   ( c<=:c:>_<: print [string tolower ${memType}]:>_cq_n[i] ),
              .ZQ    ( 1'b1 ),
              .DOFF  ( 1'b1 ),
              .QVLD  ( ),
              .ODT   (1'b1)
              );
          end
        end
      end
      if(BURST_LEN == 2) begin : BL2_INST
        if(MEM_DEVICE_WIDTH == 36) begin: X36_INST
          cyqdr2_b2 QDR2PLUS_MEM (
            .TCK    ( 1'b0 ),
            .TMS    ( 1'b1 ),
            .TDI    ( 1'b1 ),
            .TDO    (),
            .D      ( c<=:c:>_<: print [string tolower ${memType}]:>_d[(DATA_WIDTH/NUM_DEVICES*i)+:(DATA_WIDTH/NUM_DEVICES)] ),
            .Q      ( c<=:c:>_<: print [string tolower ${memType}]:>_q[(DATA_WIDTH/NUM_DEVICES*i)+:(DATA_WIDTH/NUM_DEVICES)] ),
            .A      ( c<=:c:>_<: print [string tolower ${memType}]:>_sa),
            .K      ( c<=:c:>_<: print [string tolower ${memType}]:>_k_p[i] ),
            .K_n    ( c<=:c:>_<: print [string tolower ${memType}]:>_k_n[i] ),
            .RPS_n  ( c<=:c:>_<: print [string tolower ${memType}]:>_r_n ),
            .WPS_n  ( c<=:c:>_<: print [string tolower ${memType}]:>_w_n ),
            .BW0_n  ( c<=:c:>_<: print [string tolower ${memType}]:>_bw_n[(4*i)+0] ),
            .BW1_n  ( c<=:c:>_<: print [string tolower ${memType}]:>_bw_n[(4*i)+1] ),
            .BW2_n  ( c<=:c:>_<: print [string tolower ${memType}]:>_bw_n[(4*i)+2] ),
            .BW3_n  ( c<=:c:>_<: print [string tolower ${memType}]:>_bw_n[(4*i)+3] ),
            .CQ     ( c<=:c:>_<: print [string tolower ${memType}]:>_cq_p[i] ),
            .CQ_n   ( c<=:c:>_<: print [string tolower ${memType}]:>_cq_n[i] ),
            .ZQ     ( 1'b1 ),
            .DOFF_b ( 1'b1 ),
            .QVLD   ( ),
            .ODT    (1'b1)
            );
        end
        if(MEM_DEVICE_WIDTH == 18) begin: X18_INST
          cyqdr2_b2 QDR2PLUS_MEM (
            .TCK    ( 1'b0 ),
            .TMS    ( 1'b1 ),
            .TDI    ( 1'b1 ),
            .TDO    (),
            .D      ( c<=:c:>_<: print [string tolower ${memType}]:>_d[(DATA_WIDTH/NUM_DEVICES*i)+:(DATA_WIDTH/NUM_DEVICES)] ),
            .Q      ( c<=:c:>_<: print [string tolower ${memType}]:>_q[(DATA_WIDTH/NUM_DEVICES*i)+:(DATA_WIDTH/NUM_DEVICES)] ),
            .A      ( c<=:c:>_<: print [string tolower ${memType}]:>_sa),
            .K      ( c<=:c:>_<: print [string tolower ${memType}]:>_k_p[i] ),
            .K_n    ( c<=:c:>_<: print [string tolower ${memType}]:>_k_n[i] ),
            .RPS_n  ( c<=:c:>_<: print [string tolower ${memType}]:>_r_n ),
            .WPS_n  ( c<=:c:>_<: print [string tolower ${memType}]:>_w_n ),
            .BW0_n  ( c<=:c:>_<: print [string tolower ${memType}]:>_bw_n[(2*i)+0] ),
            .BW1_n  ( c<=:c:>_<: print [string tolower ${memType}]:>_bw_n[(2*i)+1] ),
            .CQ     ( c<=:c:>_<: print [string tolower ${memType}]:>_cq_p[i] ),
            .CQ_n   ( c<=:c:>_<: print [string tolower ${memType}]:>_cq_n[i] ),
            .ZQ     ( 1'b1 ),
            .DOFF_b ( 1'b1 ),
            .QVLD   ( ),
            .ODT   (1'b1)
            );
        end
      end
    end
  endgenerate
     <: } :>
     <: } :>

<:if { ( [ string tolower [ getmodelparam C0.QDRIIP_IS_CUSTOM ] ] == "true") } {:>
initial
begin : Logging
    $display("SIMULATIONS NOT SUPPORTED FOR CUSTOM PART");
    $finish;
end
<:}:>
endmodule
